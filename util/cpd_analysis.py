# Heuristic script to help me determine potential full functions to put in 
# the semgrep_analysis_input/sca_analysis_fns text files folder. This script
# runs with the pretense that you have already run the source code analysis
# script. After extracting the functions outputted by this script, I reread
# them to ensure they were full functions. The results of this hand-picking
# are in semgrep_analysis_input/sca_analysis_fns.

import os

important_chars = ["{", "}", "(", ")", ";"]

current_working_dir = os.getcwd()
sca_work_dir = "sca_analysis_output"
sca_fn_dir = "sca_analysis_fns"
sca_postgres_dir = "sca_analysis_postgres"
breaker = "====================================================================="
path = current_working_dir + "/" + sca_work_dir

for file in os.listdir(path):
  # The file names are in the format extnname_cpd.txt. file_name[:-4] extracts
  # the extension name.
  file_name = os.path.splitext(file)[0]
  extn_name = file_name[:-4]

  # Two output files, one of which explicitly has only functions copied in core 
  #  PostgreSQL, the other is just any function denoted as copied by CPD.
  postgres_err_file = open(current_working_dir + "/" + sca_postgres_dir + "/" + extn_name + "_postgres.txt", "w")
  fn_err_file = open(current_working_dir + "/" + sca_fn_dir + "/" + extn_name + "_fn.txt", "w")

  # We open the input file, generated by CPD, that compares its codebase to
  # PostgreSQL. Then we check whether the code copied has the characters (, ),
  # {, },;. If these five characters exist, we write all the flagged code to
  # the output files.
  file_obj = open(path + "/" + file, "r")
  file_lines = file_obj.readlines()
  file_str = "".join(file_lines)
  errors_list = file_str.split(breaker)
  print("Determining potential functions for " + file)
  for err in errors_list:
    flag = True
    for ic in important_chars:
      if ic not in err:
        flag = False
    if "postgresql-15.3/src" in err:
      postgres_err_file.write(err)
      if flag:
        fn_err_file.write(err)

  postgres_err_file.close()
  fn_err_file.close()